
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/danielllmuniz/devices-api/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/danielllmuniz/devices-api/cmd/terndotenv/main.go (0.0%)</option>
				
				<option value="file2">github.com/danielllmuniz/devices-api/internal/api/device_handlers.go (88.9%)</option>
				
				<option value="file3">github.com/danielllmuniz/devices-api/internal/api/routers.go (0.0%)</option>
				
				<option value="file4">github.com/danielllmuniz/devices-api/internal/jsonutils/jsonutils.go (90.9%)</option>
				
				<option value="file5">github.com/danielllmuniz/devices-api/internal/services/device_service.go (88.5%)</option>
				
				<option value="file6">github.com/danielllmuniz/devices-api/internal/store/mockstore/mock_device_store.go (100.0%)</option>
				
				<option value="file7">github.com/danielllmuniz/devices-api/internal/store/pgstore/db.go (0.0%)</option>
				
				<option value="file8">github.com/danielllmuniz/devices-api/internal/store/pgstore/devices.sql.go (0.0%)</option>
				
				<option value="file9">github.com/danielllmuniz/devices-api/internal/store/pgstore/models.go (0.0%)</option>
				
				<option value="file10">github.com/danielllmuniz/devices-api/internal/store/pgstore/pg_device_store.go (0.0%)</option>
				
				<option value="file11">github.com/danielllmuniz/devices-api/internal/validator/device/create_device.go (100.0%)</option>
				
				<option value="file12">github.com/danielllmuniz/devices-api/internal/validator/device/patch_device.go (100.0%)</option>
				
				<option value="file13">github.com/danielllmuniz/devices-api/internal/validator/device/update_device.go (100.0%)</option>
				
				<option value="file14">github.com/danielllmuniz/devices-api/internal/validator/validator.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"

        "github.com/danielllmuniz/devices-api/internal/api"
        "github.com/danielllmuniz/devices-api/internal/services"
        "github.com/danielllmuniz/devices-api/internal/store/pgstore"
        "github.com/go-chi/chi/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/joho/godotenv"
)

func main() <span class="cov0" title="0">{
        // LOAD ENVIRONMENT VARIABLES
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // LOAD CONTEXT
        <span class="cov0" title="0">ctx := context.Background()

        // DATABASE CONNECTION
        pool, err := pgxpool.New(ctx, fmt.Sprintf("user=%s password=%s host=%s port=%s dbname=%s",
                os.Getenv("DATABASE_USER"),
                os.Getenv("DATABASE_PASSWORD"),
                os.Getenv("DATABASE_HOST"),
                os.Getenv("DATABASE_PORT"),
                os.Getenv("DATABASE_NAME"),
        ))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer pool.Close()
        if err := pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // START SERVER
        <span class="cov0" title="0">app := api.Api{
                Router:        chi.NewMux(),
                DeviceService: *services.NewDeviceService(pgstore.NewPGDeviceStore(pool)),
        }

        app.BindRoutes()

        go func() </span><span class="cov0" title="0">{
                if err := http.ListenAndServe(fmt.Sprintf(
                        "%s:%s",
                        os.Getenv("API_HOST"),
                        os.Getenv("API_PORT"),
                ), app.Router); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }()
        <span class="cov0" title="0">fmt.Printf("Server running on %s:%s\n", os.Getenv("API_HOST"), os.Getenv("API_PORT"))
        fmt.Printf("Press CTRL+C to stop\n")
        select </span>{}
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "strings"

        "github.com/joho/godotenv"
)

func main() <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">args := []string{
                "migrate",
        }

        // Check for a custom steps argument like steps=1
        for _, arg := range os.Args[1:] </span><span class="cov0" title="0">{
                if strings.HasPrefix(arg, "steps=") </span><span class="cov0" title="0">{
                        // You can customize this destination flag as needed
                        args = []string{
                                "migrate",
                                "--destination", "-1",
                        }
                        break</span>
                }
        }

        // Add common flags
        <span class="cov0" title="0">args = append(args,
                "--migrations", "./internal/store/pgstore/migrations",
                "--config", "./internal/store/pgstore/migrations/tern.conf",
        )

        cmd := exec.Command("tern", args...)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Command execution failed: ", err)
                fmt.Println("Output: ", string(output))
                panic(err)</span>
        }

        <span class="cov0" title="0">fmt.Println("Command executed successfully:", string(output))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/danielllmuniz/devices-api/internal/jsonutils"
        "github.com/danielllmuniz/devices-api/internal/services"
        "github.com/danielllmuniz/devices-api/internal/store"
        deviceValidator "github.com/danielllmuniz/devices-api/internal/validator/device"
        "github.com/go-chi/chi/v5"
)

func (api *Api) handleCreateDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        data, problems, err := jsonutils.DecodeValidJson[deviceValidator.CreateDeviceReq](r)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                fmt.Println(problems)
                if problems == nil </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusBadRequest, map[string]any{
                                "error": "invalid request",
                        })
                        return
                }</span>

                <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusUnprocessableEntity, problems)
                return</span>
        }

        <span class="cov8" title="1">device, err := api.DeviceService.CreateDevice(
                r.Context(),
                data.Name,
                data.Brand,
                data.State,
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                jsonutils.EncodeJson(w, r, http.StatusInternalServerError, map[string]any{
                        "error": "failed to create device, try again later",
                })
                return
        }</span>

        <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusCreated, map[string]any{
                "message": "device created successfully",
                "device": map[string]any{
                        "id":         device.ID,
                        "name":       device.Name,
                        "brand":      device.Brand,
                        "state":      device.State,
                        "created_at": device.CreatedAt,
                },
        })</span>
}

func (api *Api) handleGetDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        strDeviceID := chi.URLParam(r, "device_id")

        intDeviceID, err := strconv.Atoi(strDeviceID)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                jsonutils.EncodeJson(w, r, http.StatusBadRequest, map[string]any{
                        "error": "invalid device id",
                })
                return
        }</span>

        <span class="cov8" title="1">device, err := api.DeviceService.GetDeviceByID(r.Context(), int32(intDeviceID))
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                jsonutils.EncodeJson(w, r, http.StatusNotFound, map[string]any{
                        "error": "device not found",
                })
                return
        }</span>

        <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusOK, map[string]any{
                "device": map[string]any{
                        "id":         device.ID,
                        "name":       device.Name,
                        "brand":      device.Brand,
                        "state":      device.State,
                        "created_at": device.CreatedAt,
                },
        })</span>
}

func (api *Api) handleGetAllDevices(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        queryParams := r.URL.Query()
        brand := queryParams.Get("brand")
        state := queryParams.Get("state")

        devices, err := api.DeviceService.GetAllDevices(r.Context(), brand, store.DeviceState(state))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                jsonutils.EncodeJson(w, r, http.StatusNotFound, map[string]any{
                        "error": "no devices found",
                })
                return
        }</span>

        <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusOK, map[string]any{
                "devices": devices,
        })</span>
}

func (api *Api) handleUpdateDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        strDeviceID := chi.URLParam(r, "device_id")

        intDeviceID, err := strconv.Atoi(strDeviceID)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                jsonutils.EncodeJson(w, r, http.StatusBadRequest, map[string]any{
                        "error": "invalid device id",
                })
                return
        }</span>

        <span class="cov8" title="1">data, problems, err := jsonutils.DecodeValidJson[deviceValidator.UpdateDeviceReq](r)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                fmt.Println(problems)
                if problems == nil </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusBadRequest, map[string]any{
                                "error": "invalid request",
                        })
                        return
                }</span>

                <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusUnprocessableEntity, problems)
                return</span>
        }

        <span class="cov8" title="1">device, err := api.DeviceService.UpdateDevice(
                r.Context(),
                int32(intDeviceID),
                data.Name,
                data.Brand,
                store.DeviceState(data.State),
        )
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                if errors.Is(err, services.ErrDeviceInUse) </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusUnprocessableEntity, map[string]any{
                                "error": "device is in use, cannot update name or brand",
                        })
                        return
                }</span>

                <span class="cov8" title="1">if errors.Is(err, services.ErrDeviceNotFound) </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusNotFound, map[string]any{
                                "error": "device not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">jsonutils.EncodeJson(w, r, http.StatusInternalServerError, map[string]any{
                        "error": "failed to update device, try again later",
                })
                return</span>
        }

        <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusOK, map[string]any{
                "message": "device updated successfully",
                "device": map[string]any{
                        "id":         device.ID,
                        "name":       device.Name,
                        "brand":      device.Brand,
                        "state":      device.State,
                        "created_at": device.CreatedAt,
                },
        })</span>
}

func (api *Api) handlePatchDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        strDeviceID := chi.URLParam(r, "device_id")

        intDeviceID, err := strconv.Atoi(strDeviceID)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                jsonutils.EncodeJson(w, r, http.StatusBadRequest, map[string]any{
                        "error": "invalid device id",
                })
                return
        }</span>

        <span class="cov8" title="1">data, problems, err := jsonutils.DecodeValidJson[deviceValidator.PatchDeviceReq](r)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                fmt.Println(problems)
                if problems == nil </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusBadRequest, map[string]any{
                                "error": "invalid request",
                        })
                        return
                }</span>
                <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusUnprocessableEntity, problems)
                return</span>
        }

        <span class="cov8" title="1">device, err := api.DeviceService.PatchDevice(
                r.Context(),
                int32(intDeviceID),
                data.Name,
                data.Brand,
                store.DeviceState(data.State),
        )
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                if errors.Is(err, services.ErrDeviceInUse) </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusUnprocessableEntity, map[string]any{
                                "error": "device is in use, cannot update name or brand",
                        })
                        return
                }</span>

                <span class="cov8" title="1">if errors.Is(err, services.ErrDeviceNotFound) </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusNotFound, map[string]any{
                                "error": "device not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">jsonutils.EncodeJson(w, r, http.StatusInternalServerError, map[string]any{
                        "error": "failed to update device, try again later",
                })
                return</span>
        }

        <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusOK, map[string]any{
                "message": "device patched successfully",
                "device": map[string]any{
                        "id":         device.ID,
                        "name":       device.Name,
                        "brand":      device.Brand,
                        "state":      device.State,
                        "created_at": device.CreatedAt,
                },
        })</span>
}

func (api *Api) handleDeleteDevice(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        strDeviceID := chi.URLParam(r, "device_id")

        intDeviceID, err := strconv.Atoi(strDeviceID)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                jsonutils.EncodeJson(w, r, http.StatusBadRequest, map[string]any{
                        "error": "invalid device id",
                })
                return
        }</span>

        <span class="cov8" title="1">id, err := api.DeviceService.DeleteDevice(r.Context(), int32(intDeviceID))
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println(err.Error())
                if errors.Is(err, services.ErrDeviceInUse) </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusUnprocessableEntity, map[string]any{
                                "error": "device is in use, cannot update name or brand",
                        })
                        return
                }</span>

                <span class="cov8" title="1">if errors.Is(err, services.ErrDeviceNotFound) </span><span class="cov8" title="1">{
                        jsonutils.EncodeJson(w, r, http.StatusNotFound, map[string]any{
                                "error": "device not found",
                        })
                        return
                }</span>
                <span class="cov0" title="0">jsonutils.EncodeJson(w, r, http.StatusInternalServerError, map[string]any{
                        "error": "failed to update device, try again later",
                })
                return</span>
        }

        <span class="cov8" title="1">jsonutils.EncodeJson(w, r, http.StatusOK, map[string]any{
                "message":   "device deleted successfully",
                "device_id": id,
        })</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func (api *Api) BindRoutes() <span class="cov0" title="0">{
        api.Router.Use(middleware.RequestID, middleware.Logger, middleware.Recoverer)

        api.Router.Route("/api", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Route("/v1", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/devices", api.handleCreateDevice)
                        r.Get("/devices", api.handleGetAllDevices)
                        r.Get("/devices/{device_id}", api.handleGetDevice)
                        r.Patch("/devices/{device_id}", api.handlePatchDevice)
                        r.Delete("/devices/{device_id}", api.handleDeleteDevice)
                        r.Put("/devices/{device_id}", api.handleUpdateDevice)
                }</span>)
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package jsonutils

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/danielllmuniz/devices-api/internal/validator"
)

func EncodeJson[T any](w http.ResponseWriter, r *http.Request, statusCode int, data T) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "Application/json")
        w.WriteHeader(statusCode)
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode json %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func DecodeValidJson[T validator.Validator](r *http.Request) (T, map[string]string, error) <span class="cov8" title="1">{
        var data T
        if err := json.NewDecoder(r.Body).Decode(&amp;data); err != nil </span><span class="cov8" title="1">{
                return data, nil, fmt.Errorf("decode json %w", err)
        }</span>

        <span class="cov8" title="1">if problems := data.Valid(r.Context()); len(problems) &gt; 0 </span><span class="cov8" title="1">{
                return data, problems, fmt.Errorf("invalid %T: %d problems", data, len(problems))
        }</span>

        <span class="cov8" title="1">return data, nil, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package services

import (
        "context"
        "errors"

        "github.com/danielllmuniz/devices-api/internal/store"
)

var (
        ErrDeviceInUse         = errors.New("device is currently in use and cannot be modified or deleted")
        ErrCannotUpdateCreated = errors.New("creation time cannot be updated")
        ErrDeviceNotFound      = errors.New("device not found")
)

type DeviceService struct {
        Store store.DeviceStore
}

func NewDeviceService(store store.DeviceStore) *DeviceService <span class="cov8" title="1">{
        return &amp;DeviceService{Store: store}
}</span>

func (s *DeviceService) CreateDevice(ctx context.Context, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov8" title="1">{
        device, err := s.Store.CreateDevice(ctx, name, brand, state)
        if err != nil </span><span class="cov8" title="1">{
                return store.Device{}, err
        }</span>
        <span class="cov8" title="1">return device, nil</span>
}

func (s *DeviceService) UpdateDevice(ctx context.Context, id int32, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov8" title="1">{
        device, err := s.Store.GetDeviceByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return store.Device{}, ErrDeviceNotFound
        }</span>

        <span class="cov8" title="1">if device.State == store.DeviceStateInUse &amp;&amp; (name != device.Name || brand != device.Brand) </span><span class="cov8" title="1">{
                return store.Device{}, ErrDeviceInUse
        }</span>

        <span class="cov8" title="1">deviceUpdated, err := s.Store.UpdateDevice(ctx, id, name, brand, state)
        if err != nil </span><span class="cov0" title="0">{
                return store.Device{}, err
        }</span>
        <span class="cov8" title="1">return deviceUpdated, nil</span>
}

func (s *DeviceService) PatchDevice(ctx context.Context, id int32, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov8" title="1">{
        device, err := s.Store.GetDeviceByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return store.Device{}, ErrDeviceNotFound
        }</span>

        <span class="cov8" title="1">if device.State == store.DeviceStateInUse &amp;&amp; (name != device.Name || brand != device.Brand) </span><span class="cov8" title="1">{
                return store.Device{}, ErrDeviceInUse
        }</span>

        <span class="cov8" title="1">deviceUpdated, err := s.Store.PatchDevice(ctx, id, name, brand, state)
        if err != nil </span><span class="cov0" title="0">{
                return store.Device{}, err
        }</span>
        <span class="cov8" title="1">return deviceUpdated, nil</span>
}

func (s *DeviceService) GetDeviceByID(ctx context.Context, id int32) (store.Device, error) <span class="cov8" title="1">{
        device, err := s.Store.GetDeviceByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return store.Device{}, ErrDeviceNotFound
        }</span>
        <span class="cov8" title="1">return device, nil</span>
}

func (s *DeviceService) GetAllDevices(ctx context.Context, brand string, state store.DeviceState) ([]store.Device, error) <span class="cov8" title="1">{

        if brand != "" &amp;&amp; state != "" </span><span class="cov8" title="1">{
                devices, err := s.Store.GetDevicesByBrandAndState(ctx, brand, state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return devices, nil</span>
        } else<span class="cov8" title="1"> if brand != "" </span><span class="cov8" title="1">{
                devices, err := s.Store.GetDevicesByBrand(ctx, brand)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return devices, nil</span>
        } else<span class="cov8" title="1"> if state != "" </span><span class="cov8" title="1">{
                devices, err := s.Store.GetDevicesByState(ctx, state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return devices, nil</span>
        }
        <span class="cov8" title="1">devices, err := s.Store.GetAllDevices(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return devices, nil</span>
}

func (s *DeviceService) DeleteDevice(ctx context.Context, id int32) (int32, error) <span class="cov8" title="1">{
        device, err := s.Store.GetDeviceByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return 0, ErrDeviceNotFound
        }</span>

        <span class="cov8" title="1">if device.State == store.DeviceStateInUse </span><span class="cov8" title="1">{
                return 0, ErrDeviceInUse
        }</span>

        <span class="cov8" title="1">return s.Store.DeleteDevice(ctx, id)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package mockstore

import (
        "context"
        "errors"
        "sync"

        "github.com/danielllmuniz/devices-api/internal/store"
)

type MockDeviceStore struct {
        mu      sync.Mutex
        devices map[int32]store.Device
        nextID  int32
}

func NewMockDeviceStore() *MockDeviceStore <span class="cov8" title="1">{
        return &amp;MockDeviceStore{
                devices: make(map[int32]store.Device),
                nextID:  1,
        }
}</span>

func (m *MockDeviceStore) CreateDevice(ctx context.Context, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if state != store.DeviceStateAvailable &amp;&amp; state != store.DeviceStateInUse &amp;&amp; state != store.DeviceStateInactive </span><span class="cov8" title="1">{
                return store.Device{}, errors.New("invalid state")
        }</span>

        <span class="cov8" title="1">device := store.Device{
                ID:    m.nextID,
                Name:  name,
                Brand: brand,
                State: state,
        }
        m.devices[m.nextID] = device
        m.nextID++

        return device, nil</span>
}

func (m *MockDeviceStore) UpdateDevice(ctx context.Context, id int32, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, ok := m.devices[id]; !ok </span><span class="cov8" title="1">{
                return store.Device{}, errors.New("device not found")
        }</span>

        <span class="cov8" title="1">device := store.Device{
                ID:    id,
                Name:  name,
                Brand: brand,
                State: state,
        }
        m.devices[id] = device
        return device, nil</span>
}

func (m *MockDeviceStore) PatchDevice(ctx context.Context, id int32, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        device, ok := m.devices[id]
        if !ok </span><span class="cov8" title="1">{
                return store.Device{}, errors.New("device not found")
        }</span>

        <span class="cov8" title="1">if name != "" </span><span class="cov8" title="1">{
                device.Name = name
        }</span>
        <span class="cov8" title="1">if brand != "" </span><span class="cov8" title="1">{
                device.Brand = brand
        }</span>
        <span class="cov8" title="1">if state != "" </span><span class="cov8" title="1">{
                device.State = state
        }</span>
        <span class="cov8" title="1">m.devices[id] = device

        return device, nil</span>
}

func (m *MockDeviceStore) GetDeviceByID(ctx context.Context, id int32) (store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        device, ok := m.devices[id]
        if !ok </span><span class="cov8" title="1">{
                return store.Device{}, errors.New("device not found")
        }</span>
        <span class="cov8" title="1">return device, nil</span>
}

func (m *MockDeviceStore) GetAllDevices(ctx context.Context) ([]store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        var result []store.Device
        for _, device := range m.devices </span><span class="cov8" title="1">{
                result = append(result, device)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func (m *MockDeviceStore) GetDevicesByBrand(ctx context.Context, brand string) ([]store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        var result []store.Device
        for _, device := range m.devices </span><span class="cov8" title="1">{
                if device.Brand == brand </span><span class="cov8" title="1">{
                        result = append(result, device)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (m *MockDeviceStore) GetDevicesByState(ctx context.Context, state store.DeviceState) ([]store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        var result []store.Device
        for _, device := range m.devices </span><span class="cov8" title="1">{
                if device.State == state </span><span class="cov8" title="1">{
                        result = append(result, device)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (m *MockDeviceStore) GetDevicesByBrandAndState(ctx context.Context, brand string, state store.DeviceState) ([]store.Device, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        var result []store.Device
        for _, device := range m.devices </span><span class="cov8" title="1">{
                if device.Brand == brand &amp;&amp; device.State == state </span><span class="cov8" title="1">{
                        result = append(result, device)
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func (m *MockDeviceStore) DeleteDevice(ctx context.Context, id int32) (int32, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, ok := m.devices[id]; !ok </span><span class="cov8" title="1">{
                return 0, errors.New("device not found")
        }</span>
        <span class="cov8" title="1">delete(m.devices, id)
        return id, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package pgstore

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: devices.sql

package pgstore

import (
        "context"
)

const createDevice = `-- name: CreateDevice :one
INSERT INTO devices (name, brand, state)
VALUES ($1, $2, $3)
RETURNING id, name, brand, state, created_at
`

type CreateDeviceParams struct {
        Name  string      `json:"name"`
        Brand string      `json:"brand"`
        State DeviceState `json:"state"`
}

func (q *Queries) CreateDevice(ctx context.Context, arg CreateDeviceParams) (Device, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, createDevice, arg.Name, arg.Brand, arg.State)
        var i Device
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Brand,
                &amp;i.State,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteDevice = `-- name: DeleteDevice :one
DELETE FROM devices
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteDevice(ctx context.Context, id int32) (int32, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, deleteDevice, id)
        err := row.Scan(&amp;id)
        return id, err
}</span>

const getAllDevices = `-- name: GetAllDevices :many
SELECT id, name, brand, state, created_at
FROM devices
ORDER BY created_at DESC
`

func (q *Queries) GetAllDevices(ctx context.Context) ([]Device, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getAllDevices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Device
        for rows.Next() </span><span class="cov0" title="0">{
                var i Device
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Brand,
                        &amp;i.State,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getDeviceById = `-- name: GetDeviceById :one
SELECT id, name, brand, state, created_at
FROM devices
WHERE id = $1
`

func (q *Queries) GetDeviceById(ctx context.Context, id int32) (Device, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, getDeviceById, id)
        var i Device
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Brand,
                &amp;i.State,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getDevicesByBrand = `-- name: GetDevicesByBrand :many
SELECT id, name, brand, state, created_at
FROM devices
WHERE LOWER(brand) = LOWER($1)
ORDER BY created_at DESC
`

func (q *Queries) GetDevicesByBrand(ctx context.Context, lower string) ([]Device, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getDevicesByBrand, lower)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Device
        for rows.Next() </span><span class="cov0" title="0">{
                var i Device
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Brand,
                        &amp;i.State,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getDevicesByBrandAndState = `-- name: GetDevicesByBrandAndState :many
SELECT id, name, brand, state, created_at
FROM devices
WHERE LOWER(brand) = LOWER($1) AND state = $2
ORDER BY created_at DESC
`

type GetDevicesByBrandAndStateParams struct {
        Lower string      `json:"lower"`
        State DeviceState `json:"state"`
}

func (q *Queries) GetDevicesByBrandAndState(ctx context.Context, arg GetDevicesByBrandAndStateParams) ([]Device, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getDevicesByBrandAndState, arg.Lower, arg.State)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Device
        for rows.Next() </span><span class="cov0" title="0">{
                var i Device
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Brand,
                        &amp;i.State,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getDevicesByState = `-- name: GetDevicesByState :many
SELECT id, name, brand, state, created_at
FROM devices
WHERE state = $1
ORDER BY created_at DESC
`

func (q *Queries) GetDevicesByState(ctx context.Context, state DeviceState) ([]Device, error) <span class="cov0" title="0">{
        rows, err := q.db.Query(ctx, getDevicesByState, state)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Device
        for rows.Next() </span><span class="cov0" title="0">{
                var i Device
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Brand,
                        &amp;i.State,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const patchDevice = `-- name: PatchDevice :one
UPDATE devices
SET name = COALESCE(NULLIF($2, ''), name),
    brand = COALESCE(NULLIF($3, ''), brand),
    state = CASE WHEN $4 = '' THEN state ELSE $4::device_state END
WHERE id = $1
RETURNING id, name, brand, state, created_at
`

type PatchDeviceParams struct {
        ID      int32       `json:"id"`
        Column2 interface{} `json:"column_2"`
        Column3 interface{} `json:"column_3"`
        Column4 interface{} `json:"column_4"`
}

func (q *Queries) PatchDevice(ctx context.Context, arg PatchDeviceParams) (Device, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, patchDevice,
                arg.ID,
                arg.Column2,
                arg.Column3,
                arg.Column4,
        )
        var i Device
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Brand,
                &amp;i.State,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const updateDevice = `-- name: UpdateDevice :one
UPDATE devices
SET name = $2,
    brand = $3,
    state = $4
WHERE id = $1
RETURNING id, name, brand, state, created_at
`

type UpdateDeviceParams struct {
        ID    int32       `json:"id"`
        Name  string      `json:"name"`
        Brand string      `json:"brand"`
        State DeviceState `json:"state"`
}

func (q *Queries) UpdateDevice(ctx context.Context, arg UpdateDeviceParams) (Device, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, updateDevice,
                arg.ID,
                arg.Name,
                arg.Brand,
                arg.State,
        )
        var i Device
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Brand,
                &amp;i.State,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package pgstore

import (
        "database/sql/driver"
        "fmt"
        "time"
)

type DeviceState string

const (
        DeviceStateAvailable DeviceState = "available"
        DeviceStateInUse     DeviceState = "in-use"
        DeviceStateInactive  DeviceState = "inactive"
)

func (e *DeviceState) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = DeviceState(s)</span>
        case string:<span class="cov0" title="0">
                *e = DeviceState(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for DeviceState: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullDeviceState struct {
        DeviceState DeviceState `json:"device_state"`
        Valid       bool        `json:"valid"` // Valid is true if DeviceState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDeviceState) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.DeviceState, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.DeviceState.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullDeviceState) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.DeviceState), nil</span>
}

type Device struct {
        ID        int32       `json:"id"`
        Name      string      `json:"name"`
        Brand     string      `json:"brand"`
        State     DeviceState `json:"state"`
        CreatedAt time.Time   `json:"created_at"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package pgstore

import (
        "context"

        "github.com/danielllmuniz/devices-api/internal/store"
        "github.com/jackc/pgx/v5/pgxpool"
)

type PGDeviceStore struct {
        Queries *Queries
        db      *pgxpool.Pool
}

func NewPGDeviceStore(db *pgxpool.Pool) *PGDeviceStore <span class="cov0" title="0">{
        return &amp;PGDeviceStore{
                Queries: New(db),
                db:      db,
        }
}</span>

func (s *PGDeviceStore) CreateDevice(ctx context.Context, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov0" title="0">{
        device, err := s.Queries.CreateDevice(ctx, CreateDeviceParams{
                Name:  name,
                Brand: brand,
                State: DeviceState(state),
        })
        if err != nil </span><span class="cov0" title="0">{
                return store.Device{}, err
        }</span>
        <span class="cov0" title="0">return store.Device{
                ID:        device.ID,
                Name:      device.Name,
                Brand:     device.Brand,
                State:     store.DeviceState(device.State),
                CreatedAt: device.CreatedAt,
        }, nil</span>
}

func (s *PGDeviceStore) UpdateDevice(ctx context.Context, id int32, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov0" title="0">{
        device, err := s.Queries.UpdateDevice(ctx, UpdateDeviceParams{
                ID:    id,
                Name:  name,
                Brand: brand,
                State: DeviceState(state),
        })
        if err != nil </span><span class="cov0" title="0">{
                return store.Device{}, err
        }</span>
        <span class="cov0" title="0">return store.Device{
                ID:        device.ID,
                Name:      device.Name,
                Brand:     device.Brand,
                State:     store.DeviceState(device.State),
                CreatedAt: device.CreatedAt,
        }, nil</span>
}

func (s *PGDeviceStore) PatchDevice(ctx context.Context, id int32, name, brand string, state store.DeviceState) (store.Device, error) <span class="cov0" title="0">{
        device, err := s.Queries.PatchDevice(ctx, PatchDeviceParams{
                ID:      id,
                Column2: name,
                Column3: brand,
                Column4: DeviceState(state),
        })
        if err != nil </span><span class="cov0" title="0">{
                return store.Device{}, err
        }</span>
        <span class="cov0" title="0">return store.Device{
                ID:        device.ID,
                Name:      device.Name,
                Brand:     device.Brand,
                State:     store.DeviceState(device.State),
                CreatedAt: device.CreatedAt,
        }, nil</span>
}

func (s *PGDeviceStore) GetDeviceByID(ctx context.Context, id int32) (store.Device, error) <span class="cov0" title="0">{
        device, err := s.Queries.GetDeviceById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return store.Device{}, err
        }</span>
        <span class="cov0" title="0">return store.Device{
                ID:        device.ID,
                Name:      device.Name,
                Brand:     device.Brand,
                State:     store.DeviceState(device.State),
                CreatedAt: device.CreatedAt,
        }, nil</span>
}

func (s *PGDeviceStore) GetAllDevices(ctx context.Context) ([]store.Device, error) <span class="cov0" title="0">{
        devices, err := s.Queries.GetAllDevices(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []store.Device
        for _, d := range devices </span><span class="cov0" title="0">{
                result = append(result, store.Device{
                        ID:        d.ID,
                        Name:      d.Name,
                        Brand:     d.Brand,
                        State:     store.DeviceState(d.State),
                        CreatedAt: d.CreatedAt,
                })
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *PGDeviceStore) GetDevicesByBrand(ctx context.Context, brand string) ([]store.Device, error) <span class="cov0" title="0">{
        devices, err := s.Queries.GetDevicesByBrand(ctx, brand)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []store.Device
        for _, d := range devices </span><span class="cov0" title="0">{
                result = append(result, store.Device{
                        ID:        d.ID,
                        Name:      d.Name,
                        Brand:     d.Brand,
                        State:     store.DeviceState(d.State),
                        CreatedAt: d.CreatedAt,
                })
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *PGDeviceStore) GetDevicesByState(ctx context.Context, state store.DeviceState) ([]store.Device, error) <span class="cov0" title="0">{
        devices, err := s.Queries.GetDevicesByState(ctx, DeviceState(state))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []store.Device
        for _, d := range devices </span><span class="cov0" title="0">{
                result = append(result, store.Device{
                        ID:        d.ID,
                        Name:      d.Name,
                        Brand:     d.Brand,
                        State:     store.DeviceState(d.State),
                        CreatedAt: d.CreatedAt,
                })
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *PGDeviceStore) GetDevicesByBrandAndState(ctx context.Context, brand string, state store.DeviceState) ([]store.Device, error) <span class="cov0" title="0">{
        devices, err := s.Queries.GetDevicesByBrandAndState(ctx, GetDevicesByBrandAndStateParams{
                Lower: brand,
                State: DeviceState(state),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []store.Device
        for _, d := range devices </span><span class="cov0" title="0">{
                result = append(result, store.Device{
                        ID:        d.ID,
                        Name:      d.Name,
                        Brand:     d.Brand,
                        State:     store.DeviceState(d.State),
                        CreatedAt: d.CreatedAt,
                })
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *PGDeviceStore) DeleteDevice(ctx context.Context, id int32) (int32, error) <span class="cov0" title="0">{
        deletedID, err := s.Queries.DeleteDevice(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return deletedID, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package device

import (
        "context"

        "github.com/danielllmuniz/devices-api/internal/store"
        "github.com/danielllmuniz/devices-api/internal/validator"
)

type CreateDeviceReq struct {
        Name  string            `json:"name"`
        Brand string            `json:"brand"`
        State store.DeviceState `json:"state"`
}

func (req CreateDeviceReq) Valid(ctx context.Context) validator.Evaluator <span class="cov8" title="1">{
        var eval validator.Evaluator

        eval.CheckField(validator.NotBlank(req.Name), "name", "Name is required")
        eval.CheckField(validator.MinChars(req.Name, 3) &amp;&amp; validator.MaxChars(req.Name, 255), "name", "Name must be between 3 and 255 characters")
        eval.CheckField(validator.NotBlank(req.Brand), "brand", "Brand is required")
        eval.CheckField(validator.MinChars(req.Brand, 3) &amp;&amp; validator.MaxChars(req.Brand, 255), "brand", "Brand must be between 3 and 255 characters")
        eval.CheckField(validator.NotBlank(string(req.State)), "state", "State is required")
        eval.CheckField(validator.InEnum(string(req.State), []any{store.DeviceStateAvailable, store.DeviceStateInUse, store.DeviceStateInactive}), "state", "State must be 'available', 'in-use' or 'inactive'")

        return eval
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package device

import (
        "context"

        "github.com/danielllmuniz/devices-api/internal/validator"
)

type PatchDeviceReq struct {
        Name  string `json:"name"`
        Brand string `json:"brand"`
        State string `json:"state"`
}

func (req PatchDeviceReq) Valid(ctx context.Context) validator.Evaluator <span class="cov8" title="1">{
        var eval validator.Evaluator
        if req.Name == "" &amp;&amp; req.Brand == "" &amp;&amp; req.State == "" </span><span class="cov8" title="1">{
                eval.AddFieldError("name", "At least one field must be informed")
                eval.AddFieldError("brand", "At least one field must be informed")
                eval.AddFieldError("state", "At least one field must be informed")
                return eval
        }</span>
        <span class="cov8" title="1">if req.Name != "" </span><span class="cov8" title="1">{
                eval.CheckField(validator.MinChars(req.Name, 3) &amp;&amp; validator.MaxChars(req.Name, 255), "name", "Name must be between 3 and 255 characters")
        }</span>
        <span class="cov8" title="1">if req.Brand != "" </span><span class="cov8" title="1">{
                eval.CheckField(validator.MinChars(req.Brand, 3) &amp;&amp; validator.MaxChars(req.Brand, 255), "brand", "Brand must be between 3 and 255 characters")
        }</span>
        <span class="cov8" title="1">if req.State != "" </span><span class="cov8" title="1">{
                eval.CheckField(validator.InEnum(req.State, []interface{}{"available", "in-use", "inactive"}), "state", "State must be 'available', 'in-use' or 'inactive")
        }</span>
        <span class="cov8" title="1">return eval</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package device

import (
        "context"

        "github.com/danielllmuniz/devices-api/internal/store"
        "github.com/danielllmuniz/devices-api/internal/validator"
)

type UpdateDeviceReq struct {
        Name  string `json:"name"`
        Brand string `json:"brand"`
        State string `json:"state"`
}

func (req UpdateDeviceReq) Valid(ctx context.Context) validator.Evaluator <span class="cov8" title="1">{
        var eval validator.Evaluator

        eval.CheckField(validator.NotBlank(req.Name), "name", "Name is required")
        eval.CheckField(validator.MinChars(req.Name, 3) &amp;&amp; validator.MaxChars(req.Name, 255), "name", "Name must be between 3 and 255 characters")
        eval.CheckField(validator.NotBlank(req.Brand), "brand", "Brand is required")
        eval.CheckField(validator.MinChars(req.Brand, 3) &amp;&amp; validator.MaxChars(req.Brand, 255), "brand", "Brand must be between 3 and 255 characters")
        eval.CheckField(validator.NotBlank(req.State), "state", "State is required")
        eval.CheckField(validator.InEnum(req.State, []any{store.DeviceStateAvailable, store.DeviceStateInUse, store.DeviceStateInactive}), "state", "State must be 'available', 'in-use' or 'inactive'")

        return eval
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package validator

import (
        "context"
        "fmt"
        "strings"
        "unicode/utf8"
)

type Validator interface {
        Valid(context.Context) Evaluator
}

type Evaluator map[string]string

func (e *Evaluator) AddFieldError(key, message string) <span class="cov8" title="1">{
        if *e == nil </span><span class="cov8" title="1">{
                *e = make(map[string]string)
        }</span>

        <span class="cov8" title="1">if _, exists := (*e)[key]; !exists </span><span class="cov8" title="1">{
                (*e)[key] = message
        }</span>
}

func (e *Evaluator) CheckField(ok bool, key, message string) <span class="cov8" title="1">{
        if !ok </span><span class="cov8" title="1">{
                e.AddFieldError(key, message)
        }</span>
}

func NotBlank(value string) bool <span class="cov8" title="1">{
        return strings.TrimSpace(value) != ""
}</span>

func MaxChars(value string, n int) bool <span class="cov8" title="1">{
        return utf8.RuneCountInString(value) &lt;= n
}</span>

func MinChars(value string, n int) bool <span class="cov8" title="1">{
        return utf8.RuneCountInString(value) &gt;= n
}</span>

func InEnum(value string, options []any) bool <span class="cov8" title="1">{
        for _, option := range options </span><span class="cov8" title="1">{
                if value == fmt.Sprintf("%v", option) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
